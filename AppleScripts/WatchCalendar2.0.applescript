(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
This script replicates one calendar to another.
It first copies all Exchange events to the iCloud calendar, and then deletes
any iCloud events that aren't in the Exchange calendar.  The first run will
likely take up to 30 mins, with later runs taking about 3 mins.  During the
run, the script checks to see if you're plugged in so that it doesn't kill your
battery.  Each add/delete event takes about 12 seconds to complete.

NOTE
------
Calendar.app fails to copy certain recurring events, times out and then 
crashes.  The script relaunches Calendar after a failed attempt, but the
avoidList property can be used to skip them alltogether for huge speed 
gains.

Once the target calendar syncs to iCloud, your  Watch should display the
events of your Exchange calendar.  This script relies upon having access to
an iCloud calendar whose name is stored in the iCloudCal property at the 
start of this script.

TODO:  
-- Clean up avoid list work to account for recurrence handling
-- Figure out how to hand a calendar event to a subroutine

Thom Rosario
v 1.3 -- added sqlite3 storage for recurrence handling
v 1.2.1 -- added Growl support
v 1.2 -- added rudimentary recurring meeting support
v 1.1 -- added the ability to avoid a list of events
v 1.0 -- initial functionality.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)(***************
P R E - F L I G H T
***************)use AppleScript version "2.4" -- Yosemite (10.10) or lateruse scripting additions-- use myLib : script "sqlite3"property scriptName : " Watch Calendar Replicator"property debugScript : trueproperty iCloudCal : "APLExch" -- the name of your iCloud calendarproperty exchCal : "Calendar" -- your Exchange calendarproperty tryRecurring : true -- try the recurring event copier processproperty trySQL : true -- try using SQLite3 for persistant storageproperty useGrowl : trueproperty tryAvoidance : true -- skips meetings that contain words in the list belowproperty avoidList : {"1 on 1", "QBO Meeting", "Mind Meld", "one-on-one", ¬	"GTD Planning", "AOS ISSO Meeting", "Work Business", "MP4 status meeting"}property launchDelay : 5 -- time to allow Calendar.app to loadproperty singleToken : "(@]" -- used to replace single quote in sql queriesproperty doubleToken : "[@)" -- used to replace double quote in sql queriesproperty listToken : "%~*" -- used as a delimiter when serializing a listproperty dbUID : 1property dbOrigUID : 2property dbSum : 3property dbStartDate : 4property dbEndDate : 5property dbLoc : 6property dbAllDay : 7property dbExclude : 8property dbRecur : 9property dbStatus : 10property dbStampDate : 11global dbName, sqlHead, sqlTail, sqlLoc, iCloudTbl, exchTbl, configTbl, nowset listOfiCloudEvents to {}set listOfiCloudDescs to {}set listOfiCloudStartDates to {}set listOfiCloudEndDates to {}set listOfExchEvents to {}set listOfNewValidUIDs to {}set now to current datelogMsg("Starting " & scriptName)(****************
D E B U G   L O O P
*****************)if debugScript then	-- testing sqlite functionatlity	sqlCreateDb()		-- get other data for recurrence checking	set eventUID to "1234-123423"	set origUID to "7897-798723"	set eventSum to sqlize("Quoth the Raven \"Nevermore.\"")	set trickyString to "Thing's quote:  \"Yo.\" is silly."	--set eventDesc to sqlize("Quoth the Raven 'Nevermore.'")	set eventDesc to sqlize(trickyString)	set eventStartDate to now as string	set eventEndDate to now + (1 * hours) as string	set eventLoc to sqlize("4-248")	set eventAllDay to true as string	set eventExcDates to sqlize(listToString({"One", "Two", "Three"}))	set eventRecur to "some recurrence string"	set eventStatus to "none"	set eventStamp to now as string		-- create test event 	set sqlValueString to my setSqlInsertString(eventUID, origUID, eventSum, eventStartDate, ¬		eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)	my runSql("insert into " & iCloudTbl & sqlValueString)			-- change this logic to only do one query and then parse it's results.  change getEventState so it assumes we already have the query result.	-- check to see if we have this event in the db	set qryRow to retrieveDbRow(iCloudTbl, eventUID)	-- now send the current event's stamp date, uid and current time.  The logic in the subroutine is already set		set eventState to my getEventState(qryRow, eventStamp)		-- change this logic to reflect the new status' returned (newer, older, equal and notfound)	if (eventState = "equal") then		-- nothing to do		logMsg("This event is the same as what we have in the db.")	else if (eventState = "newer") or (eventState = "older") then		-- if this is newer, then logically we should just write to db and to iCloud		-- if this is somehow older than what's in the db, then we should write just to be safe		set sqlString to my setSqlUpdateString(eventUID, origUID, eventSum, eventStartDate, ¬			eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)		set qry to "update " & iCloudTbl & sqlString	else if (eventState = "notfound") then		-- didn't find this UID; need to add it to the db		set sqlString to my setSqlInsertString(eventUID, origUID, eventSum, eventStartDate, ¬			eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)		set qry to "insert into " & iCloudTbl & sqlString	end if -- done processing the event	my runSql(qry)			(* get rid of this part	set findQry to "select * from " & iCloudTbl & " where uid = " & "'" & eventUID & "'"	set qryResult to my runSql(findQry)	if (qryResult = "") then		log "nothing here"	else		logMsg(desqlize(retrieveQryItem(qryResult, dbSum)))		logMsg(date (desqlize(retrieveQryItem(qryResult, dbStartDate))))		logMsg(stringToBoolean(desqlize(retrieveQryItem(qryResult, dbAllDay))))		logMsg(stringToList(retrieveQryItem(qryResult, dbExclude)))	end if
	*)end if -- sqlite testing	(*************
M A I N   C O D E
**************)if pluggedIn() then	configureGrowl()	sendGrowl("Started Processing", " Watch Sync Starting", "Plugged in and ready to start replicating.")	sqlCreateDb()		tell application "Calendar"		-- give Calendar some time to load & then hide it		activate		delay launchDelay		tell application "System Events" to tell process "Calendar" to set visible to false		try			-- get all events in both calendars			my logMsg("Getting Exchange calendar")			set exchEvents to events of calendar exchCal			my logMsg("Getting iCloud calendar")			set iCloudEvents to events of calendar iCloudCal						my logMsg("Creating the list of iCloud event UIDs")			repeat with theCloudEvent in iCloudEvents				-- my getEventDetails(theCloudEvent)								-- get the UID and check the db to see if we have this, and what we have to do from there				set eventUID to my checkMissing(uid of theCloudEvent)				set qryRow to retrieveDbRow(iCloudTbl, eventUID)				set eventState to my getEventState(qryRow, eventStamp)								-- Decision tree				if (eventState ≠ "equal") then					-- We have some work to do.  Get all the deets and process further					set eventDesc to my sqlize(description of theCloudEvent)					set eventStartDate to my sqlize(start date of theCloudEvent as string)					set eventEndDate to my sqlize(end date of theCloudEvent as string)					copy eventUID to end of listOfiCloudEvents					copy eventDesc to end of listOfiCloudDescs					copy eventStartDate to end of listOfiCloudStartDates					copy eventEndDate to end of listOfiCloudEndDates					set eventSum to my sqlize(summary of theCloudEvent)					set eventLoc to my sqlize(location of theCloudEvent)					set eventAllDay to my sqlize(allday event of theCloudEvent as string)					set eventExcDates to my sqlize(excluded dates of theCloudEvent as string)					set eventRecur to my sqlize(recurrence of theCloudEvent)					set eventStatus to my sqlize(status of theCloudEvent as string)					set eventStamp to my sqlize(stamp date of theCloudEvent as string)										-- create the sql query we'll run					if (eventState = "newer") or (eventState = "older") then						-- if this is newer, then logically we should just write to db and to iCloud						-- if this is somehow older than what's in the db, then we should write just to be safe						-- for calendar, need to update iCloudCalendar, too												set sqlString to my setSqlUpdateString(eventUID, origUID, eventSum, eventStartDate, ¬							eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)						set qry to "update " & iCloudTbl & sqlString					else if (eventState = "notfound") then						-- didn't find this UID; need to add it to the db						set sqlString to my setSqlInsertString(eventUID, origUID, eventSum, eventStartDate, ¬							eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)						set qry to "insert into " & iCloudTbl & sqlString						-- now we need to actually update iCloud Calendar						if eventRecur ≠ "" then							my createRecurEvent(iCloudCal, eventUID, origUID, eventSum, eventStartDate, eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)						else							-- try to create a normal new duplicate of the event													end if -- done creating calendar event					end if -- done building sql query					my runSql(qry)				end if -- done processing the event																								if not (my getEventState(eventUID, eventStamp)) then					-- this event's time stamp is 					my updateCol(iCloudTbl, eventUID, "stampdate", eventStamp)				else					-- 				end if								-- if it's new, then we'll insert				set sqlValueString to my setSqlInsertString(eventUID, eventSum, eventStartDate, eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)				my runSql("insert into " & iCloudTbl & sqlValueString)			end repeat						-- now loop through Exchange and compare every event to the iCloud events we just saved			my logMsg("Looking for Exchange events that aren't in iCloud")						-- first step is to copy every Exch event into the Exch Table				repeat with theExchEvent in exchEvents				set eventUID to my checkMissing(uid of theExchEvent)				copy eventUID to end of listOfiCloudEvents				if trySQL then					-- get all of the properties and store them in the Exchange Table					-- this data will be used to determine whether or not an iCloud event needs to be deleted					set eventSum to my sqlize(summary of theExchEvent)					set eventDesc to my sqlize(description of theExchEvent)					set eventStartDate to my sqlize(start date of theExchEvent as string)					set eventEndDate to my sqlize(end date of theExchEvent as string)					set eventLoc to my sqlize(location of theExchEvent)					set eventAllDay to my sqlize(allday event of theExchEvent as string)					set eventExcDates to my sqlize(excluded dates of theExchEvent as string)					set eventRecur to my sqlize(recurrence of theExchEvent)					set eventStatus to my sqlize(status of theExchEvent as string)					set eventStamp to my sqlize(stamp date of theExchEvent as string)										-- insert the data into the db					set sqlValueString to my setSqlInsertString(eventUID, eventSum, eventStartDate, eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)					try						my runSql("insert into " & exchTbl & sqlValueString)					on error errMsg						my logMsg("SQL error:  " & eventSum & "; " & errMsg)					end try -- done trying to add event										-- determine if this is a new Exch event					set findQry to "select * from " & iCloudTbl & " where uid = " & "'" & eventUID & "'"					set sqlResult to my runSql(findQry)										if (sqlResult = "") then						-- found an event not in iCloud						if not pluggedIn() then							my logMsg("Not plugged in -- halting execution.")							exit repeat						end if												-- is it a recurring meeting?						-- change following line to just get the value already pulled previously						set recurResult to my desqlize(my retrieveQryItem(my qryResult, dbSum))						if recurResult ≠ "" then							-- recurring event, but not one in iCloud, so we need to copy it							-- get some of the event properties and check the db for a match							-- if we find a match, then we already have this event in iCloud; should I re-copy to get latest? Compare StampDates							-- if not re-copying, then just skip for now														tell calendar iCloudCal								try									set newEvent to make new event at end with properties {description:eventDesc, location:eventLoc, summary:eventSum, start date:eventStartDate, end date:eventEndDate, recurrence:eventRecur, status:eventStatus, allday event:eventAllDay, stamp date:eventStamp}									my logMsg("Successfully created test event:  " & eventSum)									-- keep track of the new UID for second half of the replication									-- copy (uid of newEvent) to end of listOfNewValidUIDs									-- write this to the iCloud Table with the original UID, or do i use the new one?								on error errMsg									-- activate -- Calendar probably crashed; relaunch									-- delay launchDelay -- wait for the calendar to load									-- tell application "System Events" to tell process "Calendar" to set visible to true									my logMsg("Error creating recurring meeting; " & errMsg)								end try -- tried to create new recurring meeting							end tell													else							-- standard event; copy it to iCloud							duplicate theExchEvent to the end of events of calendar iCloudCal						end if												try							-- this is the old method of trying to handle recurrence							set sumString to (summary of theExchEvent)							if tryRecurring then -- let's try to handle recurrence																set recurText to (recurrence of theExchEvent)								set recurrent to (recurText ≠ missing value)								if recurrent then									-- get some event properties to see if we already have this one									set eventDesc to my checkMissing(description of theExchEvent)									set eventEndDate to my checkMissing(end date of theExchEvent)									set eventStartDate to my checkMissing(start date of theExchEvent)																		-- check now to see if we have a similar recurring event									if ((eventDesc is in listOfiCloudDescs) and ¬										(eventStartDate is in listOfiCloudStartDates) and ¬										(eventEndDate is in listOfiCloudEndDates)) then										-- found it, don't add it										my logMsg("Found a similar recurring event; skipping.")									else -- didn't find it, add it										-- get the rest of the properties										set eventAllDay to my checkMissing(allday event of theExchEvent)										set eventExcDates to my checkMissing(excluded dates of theExchEvent)										set eventLoc to my checkMissing(location of theExchEvent)										set eventRecur to my checkMissing(recurrence of theExchEvent)										set eventSeq to my checkMissing(sequence of theExchEvent)										set eventStampDate to my checkMissing(stamp date of theExchEvent)										set eventStatus to my checkMissing(status of theExchEvent)										set eventSum to my checkMissing(summary of theExchEvent)										set eventURL to my checkMissing(url of theExchEvent)																				-- try to create the new event in iCloud										tell calendar iCloudCal											try												--set newEvent to make new event at end with properties {allday event:eventAllDay, description:eventDesc, end date:eventEndDate, excluded dates:eventExcDates, location:eventLoc, recurrence:eventRecur, sequence:eventSeq, stamp date:eventStampDate, start date:eventStartDate, status:eventStatus, summary:eventSum, uid:eventUID, url:eventURL}												set newEvent to make new event at end with properties {description:eventDesc, location:eventLoc, summary:eventSum, start date:eventStartDate, end date:eventEndDate, recurrence:eventRecur}												my logMsg("Successfully created test event:  " & sumString)												-- keep track of the new UID for second half of the replication												copy (uid of newEvent) to end of listOfNewValidUIDs											on error errMsg												-- activate -- Calendar probably crashed; relaunch												-- delay launchDelay -- wait for the calendar to load												-- tell application "System Events" to tell process "Calendar" to set visible to true												my logMsg("Error creating recurring meeting; " & errMsg)											end try -- tried to create new recurring meeting										end tell									end if -- done comparing to existing events																end if -- done processing recurrent event							end if -- end of user preference to try recurrent handling														if tryAvoidance then								-- check to see if this event is on the user's blacklist								set avoid to my checkBlackList(sumString)								if avoid then									my logMsg("Avoiding:  " & sumString)								else									-- try to copy to iCloud									my logMsg("Attempting to copy:  " & sumString)									duplicate theExchEvent to the end of events of calendar iCloudCal									my logMsg("Copied:  " & sumString & " to iCloud")																		-- keep track of the new UID for second half of the replication									copy (uid of theExchEvent) to end of listOfNewValidUIDs								end if							end if -- tryAvoidance						on error errMsg							activate -- Calendar probably crashed; relaunch							delay launchDelay -- wait for the calendar to load							tell application "System Events" to tell process "Calendar" to set visible to false							my logMsg("Error copying:  " & sumString & "; " & errMsg)						end try -- done trying to add event												else						-- found this uid; stored in sqlResult						-- parse out pieces i need and make comparisons now						-- if stamp date is newer than the db, copy details back to the db						log "found a match"					end if					my logMsg(sqlResult)				end if -- tried sql								if eventUID is not in listOfiCloudEvents then				end if -- done handling unique event			end repeat -- loop through all Exchange Calendar events			my logMsg("Done looking for new Exchange events")			my sendGrowl("Status", " Watch Sync", "Done looking for new Exchange events")						-- Remove iCloud events that aren't in Exchange			-- Run through every iCloud Table UID and see if it's in the Exch Table			-- If it's not there, then we need to get that UID and delete it from iCloudCalendar						my logMsg("Refreshing the list of Exchange events") -- don't need this w/ DB approach			set exchEvents to events of calendar exchCal			my logMsg("Creating a list of Exchange event UIDs")			repeat with theExchEvent in exchEvents				copy (uid of theExchEvent) to end of listOfExchEvents			end repeat			-- can get rid of the entire section above						my logMsg("Checking each iCloud event to see if it's in Exchange")			-- need a sql query to give me just the UIDs to delete			repeat with theCloudEvent in iCloudEvents				set iCloudUID to (uid of theCloudEvent)				if ((iCloudUID) is not in listOfExchEvents) and (iCloudUID is not in listOfNewValidUIDs) then					try						if not pluggedIn() then							my logMsg("Not plugged in -- halting execution.")							exit repeat						end if						set sumString to (summary of theCloudEvent)						my logMsg("Attempting to delete:  " & sumString)						delete theCloudEvent						my logMsg("Deleted:  " & sumString)					on error errMsg						my logMsg("Error deleting:  " & sumString & "; " & errMsg)					end try				end if -- done handling missing event			end repeat -- loop through all iCloud Calendar events					my logMsg("Done cleaning up iCloud calendar")			tell application "System Events" to tell process "Calendar" to set visible to true			reload calendars		on error errMsg			--activate -- Calendar probably crashed; relaunch			--delay launchDelay -- wait for the calendar to load			tell application "System Events" to tell process "Calendar" to set visible to true			my logMsg("Error getting Exchange events; " & errMsg)		end try -- Tried to get Exchange events	end tell -- done with Calendar.appelse	my logMsg("Canceling this run since we're on battery")end if -- main loop inside power checkmy setConfig("replicationEndTime", (current date) as string)logMsg("Completed " & scriptName)sendGrowl("Processing Complete", " Watch Sync Complete", "Open iOS Calendar app to force sync.")(*************
H A N D L E R S       
**************)(* SQL Handlers *)on sqlCreateDb()	(*****************************************************
	This handler creates a SQLite3 database on the disk.  It's used to
	get around the slow performance of reading events directly from 
	calendars.  Storing the events in sql allows much faster replication.
	*****************************************************)	local sqlCols, repStartTime, qry	set dbName to "WatchCalendarSync.db"	set sqlLoc to space & "~/Library/Caches/" & dbName & space	set sqlHead to "sqlite3" & sqlLoc & quote	set sqlTail to quote	set configTbl to "config"	set exchTbl to "exch"	set iCloudTbl to "iCloud"	set sqlCols to "(uid text PRIMARY KEY, origuid text, summary text, startDate text, endDate text, location text, allday int, excludedates text, recurrence text, status text, stampdate text)"		--my runSql("drop table if exists " & exchTbl & ";")	--my runSql("drop table if exists " & iCloudTbl & ";")	--my runSql("drop table if exists " & configTbl & ";")		-- create tables if they don't exist	my runSql("create table if not exists " & exchTbl & sqlCols & "; ")	my runSql("create table if not exists " & iCloudTbl & sqlCols & "; ")		-- now create config table & set some variables	set sqlCols to "(name text, value text)"	my runSql("create table if not exists " & configTbl & sqlCols & "; ")	(*tell script "sqlite3"
		set testResult to my setConfig "dbInited", "true"
		log testResult
	end tell*)	my setConfig("dbInited", "true")	my setConfig("replicationStartTime", now as string)	end sqlCreateDbon dbInited()	-- checks to see if the db is initialized	local qryResult	set qryResult to my runSql("select value from " & configTbl & " where name = 'dbInitStatus';")	if qryResult = "" then		return false	else		return true	end ifend dbInitedon configExists(cfg)	-- checks to see if a config is null	local qryResult	set qryResult to my runSql("select value from config where name = '" & cfg & "';")	if qryResult = "" then		return false	else		return true	end ifend configExistson setConfig(cfg, val)	-- sets a config	local cfg, val, qry	if not my configExists(cfg) then		-- didn't have a value for this, so use sql insert		set qry to "insert into config values ('" & cfg & "', '" & val & "');"	else		-- update the existing sql value		set qry to "update config set value = '" & val & "' where name = '" & cfg & "';"	end if	my runSql(qry)end setConfigon getConfig(cfg, val)	-- sets a config	local cfg, val, qry	if not my configExists(cfg) then		-- didn't have a value for this, so use sql insert		set qry to "insert into config values ('" & cfg & "', '" & val & "');"	else		-- update the existing sql value		set qry to "update config set value = '" & val & "' where name = '" & cfg & "';"	end if	set cfgVal to my runSql(qry)	return cfgValend getConfigon retrieveDbRow(tbl, uid)	-- retrieves a row from a sqlite table	local tbl, uid, qry, qryResult	set qry to "select * from " & tbl & " where uid  = '" & uid & "' or origuid = '" & uid & "'"	set qryResult to my runSql(qry)	return qryResultend retrieveDbRowon getEventState(qry, eventStamp)	(*****************************************************
	This handler checks the row of sql data passed to it and compares 
	it to the date stamp of the current event we're processing & 
	returns that result.	*****************************************************)	local qry, tblStamp, eventStamp	set eventStamp to date eventStamp	if (qry ≠ "") then		-- found this UID in the database and returned a row; parse it and check dates		set tblStamp to my date (retrieveQryItem(qry, dbStampDate)) --dbStampDate is a global				if (eventStamp > tblStamp) then			return "newer"		else if (eventStamp = tblStamp) then			return "equal"		else if (eventStamp < tblStamp) then			return "older"		end if -- date stamp comparison	else		return "notfound"	end if -- null result from the query	end getEventStateon updateCol(tbl, uid, colName, colValue)	-- updates the table column with the value passed	local tbl, uid, colName, colValue, upTable, qryAction, qryCondition		set upTable to "update " & tbl	set qryAction to " set " & colName & " = '" & colValue & "'"	set qryCondition to " where (uid = '" & uid & "') or (origuid = '" & uid & "');"	my runSql(upTable & qryAction & qryCondition)end updateColon sqlize(orig)	-- text substitution routine for sanitizing sql queries	local orig, noSingleString, noDoubleString, searchString, replacementString	set orig to my checkMissing(orig)		-- replace single quotes	set AppleScript's text item delimiters to the "'"	set the itemList to every text item of orig	set AppleScript's text item delimiters to the singleToken	set noSingleString to the itemList as string		-- replace double quotes	set AppleScript's text item delimiters to the "\""	set the itemList to every text item of noSingleString	set AppleScript's text item delimiters to the doubleToken	set noDoubleString to the itemList as string	set AppleScript's text item delimiters to ""	--my logMsg(my desqlize(noDoubleString))	return noDoubleStringend sqlizeon desqlize(orig)	-- text substitution routine for sanitizing sql queries	local orig, noSingleString, noDoubleString, searchString, replacementString	set orig to my checkMissing(orig)		-- replace single quotes	set AppleScript's text item delimiters to the singleToken	set the itemList to every text item of orig	set AppleScript's text item delimiters to the "'"	set noSingleString to the itemList as string		-- replace double quotes	set AppleScript's text item delimiters to the doubleToken	set the itemList to every text item of noSingleString	set AppleScript's text item delimiters to the "\""	set noDoubleString to the itemList as string	set AppleScript's text item delimiters to ""	return noDoubleStringend desqlizeon retrieveQryItem(result, itemNum)	-- get the value list	local itemList, itemNum	set AppleScript's text item delimiters to the "|"	set the itemList to every text item of result	set AppleScript's text item delimiters to ""	return item itemNum of itemListend retrieveQryItemon runSql(qry)	-- formats query and executes	-- add head + stmt + tail then run script	try		do shell script sqlHead & qry & sqlTail	on error errMsg		my logMsg("SQL error:  " & qry & "; " & errMsg)	end tryend runSqlon setSqlInsertString(uid, origUID, summary, startDate, endDate, loc, allday, excDates, recur, stat, stamp)	-- takes the values and preps them for inserting into a row	local sqlValueString	set sqlValueString to " values (" & ¬		quoted form of uid & ", " & ¬		quoted form of origUID & ", " & ¬		quoted form of summary & ", " & ¬		quoted form of startDate & ", " & ¬		quoted form of endDate & ", " & ¬		quoted form of loc & ", " & ¬		quoted form of allday & ", " & ¬		quoted form of excDates & ", " & ¬		quoted form of recur & ", " & ¬		quoted form of stat & ", " & ¬		quoted form of stamp & ");"	return sqlValueStringend setSqlInsertStringon setSqlUpdateString(uid, origUID, summary, startDate, endDate, loc, allday, excDates, recur, stat, stamp)	-- takes the values and preps them for updating an existing row	local qry, sqlUpdateString		set sqlUpdateString to " set uid = '" & uid & "', " & ¬		"origuid = '" & origUID & "', " & ¬		"summary = '" & summary & "', " & ¬		"startDate = '" & startDate & "', " & ¬		"endDate = '" & endDate & "', " & ¬		"location = '" & loc & "', " & ¬		"allday = '" & allday & "', " & ¬		"excludedates = '" & excDates & "', " & ¬		"recurrence = '" & recur & "', " & ¬		"status = '" & stat & "', " & ¬		"stampdate = '" & stamp & "' where uid = '" & uid & "' or origuid = '" & uid & "';"	return sqlUpdateStringend setSqlUpdateString(*on escapeForSQLite3(theText, theToken)	-- replaces ' to prevent sql queries from breaking	return my replaceChars(theText, "'", theToken)end escapeForSQLite3on unescapeForSQLite3(theText, theToken)	-- replaces the token text with ' to unescape data saved in the db	return my replaceChars(theText, theToken, "'")end unescapeForSQLite3on getListOfEvents(theCalendar)	--set calEvents to events of calendar theCalendar	set listOfEvents to {}	repeat with anEvent in calEvents		copy (uid of anEvent) to end of listOfEvents	end repeatend getListOfEvents*)(* String Handlers *)on checkMissing(eventValue)	if eventValue = missing value then		return ""	else		return eventValue	end ifend checkMissingon stringToBoolean(booString)	-- converts a string to a boolean	local booString, trueBoo	if booString = "true" then		set trueBoo to true	else		set trueBoo to false	end if	return trueBooend stringToBooleanon listToString(origList)	-- converts a list to a string delimited with listToken	local origList, origDelim, stringList	set origDelim to text item delimiters	set text item delimiters to listToken	set stringList to origList as text	set text item delimiters to origDelim	return stringListend listToStringon stringToList(origString)	-- converts a string delimited with listToken to a list	local origString, origDelim, reList	set origDelim to text item delimiters	set text item delimiters to listToken	set the reList to every text item of origString	set text item delimiters to origDelim	return reListend stringToList(*on replaceChars(originalText, searchString, replacementString)	-- text substitution routine for sanitizing sql queries	local originalText, newText, searchString, replacementString	set AppleScript's text item delimiters to the searchString	set the itemList to every text item of originalText	set AppleScript's text item delimiters to the replacementString	set newText to the itemList as string	set AppleScript's text item delimiters to ""	return newTextend replaceChars*)(* Miscellaneous Handlers *)on logMsg(scriptStatus)	if debugScript then		-- Log and prompt subroutine		set now to current date		set nowString to now as string		log nowString & ":  " & scriptStatus		-- display dialog scriptName & ":  " & scriptStatus	end ifend logMsgon pluggedIn()	-- Figure out if we're on AC power vice running on battery	if debugScript then		-- chances are I'm stepping through line by line, so let it run while on battery		return true	else		-- find out the true state		do shell script "pmset -g everything | grep Cycles"		set powerState to the result		set powerSource to word 1 of powerState		if powerSource = "AC" then			return true		else			return false		end if	end ifend pluggedInon configureGrowl()	if useGrowl then		tell application "System Events"			set isRunning to (count of (every process whose bundle identifier is "com.Growl.GrowlHelperApp")) > 0		end tell				if isRunning then			tell application id "com.Growl.GrowlHelperApp"				-- Make a list of all the notification types the script will ever send:				set the allNotificationsList to {"Started Processing", "Status", "Processing Complete"}				set the enabledNotificationsList to {"Started Processing", "Status", "Processing Complete"}				register as application ¬					scriptName all notifications allNotificationsList ¬					default notifications enabledNotificationsList ¬					icon of application "Calendar"			end tell		end if -- it was running	end if -- user preference checkend configureGrowlon sendGrowl(gName, gTitle, gDesc)	if useGrowl then		tell application id "com.Growl.GrowlHelperApp"			notify with name gName title gTitle description gDesc application name scriptName		end tell	end ifend sendGrowlon checkBlackList(sumString)	-- check's the string to see if it's in the list of events the user wants to avoid	if tryAvoidance then -- user configurable option		-- If this event is in the avoidList, set the avoid flag to true		repeat with avoidEvent in avoidList			if avoidEvent is in sumString then				set foundString to true			end if		end repeat -- done checking for avoided items		if foundString then			return true		else			return false		end if	end if -- user configurable avoidance optionend checkBlackListon getEventDetails(calEvent)	-- try to read properties from a passed event	local calEvent, startDate, endDate, allday, excluded, stamp, test	set startDate to "start date"	set endDate to "end date"	set allday to "allday event"	set excluded to "excluded dates"	set stamp to "stamp date"		set test to "string"	log uid of calEvent	try		log uid of calEvent as text	on error errMsg		log errMsg	end try	try		set test to uid of calEvent	on error errMsg		log errMsg	end try	try		set test to text of (uid of calEvent)	on error errMsg		log errMsg	end try	set eventUID to my checkMissing(uid of calEvent)	set eventDesc to my sqlize(description of calEvent)	set eventStartDate to my sqlize(startDate of calEvent as string)	set eventEndDate to my sqlize(endDate of calEvent as string)	set eventSum to my sqlize(summary of calEvent)	set eventLoc to my sqlize(location of calEvent)	set eventAllDay to my sqlize(allday of calEvent as string)	set eventExcDates to my sqlize(excluded of calEvent as string)	set eventRecur to my sqlize(recurrence of calEvent)	set eventStatus to my sqlize(status of calEvent as string)	set eventStamp to my sqlize(stamp of calEvent as string)	return calEventend getEventDetailson createRecurEvent(cal, eventUID, eventSum, eventStartDate, eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp)	-- create a new recurring calendar event and write the new event details to the db	local cal, eventUID, recurUID, eventSum, eventStartDate, eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, eventStamp, recurStamp, newEvent, sqlString		tell application "Calendar"		tell calendar cal			try				set newEvent to make new event at end with properties {description:eventDesc, location:eventLoc, summary:eventSum, start date:eventStartDate, end date:eventEndDate, recurrence:eventRecur, status:eventStatus, allday event:eventAllDay, stamp date:eventStamp}				my logMsg("Successfully created a new recurring event:  " & eventSum)				-- write to sql here				-- get the actual UID & time stamp				set recurUID to my checkMissing(uid of newEvent)				set recurStamp to my sqlize(stamp date of newEvent as string)								-- create the query string and then insert the data into the db				set sqlString to my setSqlInsertString(recurUID, eventUID, eventSum, eventStartDate, ¬					eventEndDate, eventLoc, eventAllDay, eventExcDates, eventRecur, eventStatus, recurStamp)				set qry to "insert into " & iCloudTbl & sqlString				my runSql(qry)			on error errMsg				-- activate -- Calendar probably crashed; relaunch				-- delay launchDelay -- wait for the calendar to load				-- tell application "System Events" to tell process "Calendar" to set visible to true				my logMsg("Error creating recurring meeting; " & errMsg)			end try -- tried to create new recurring meeting		end tell -- done with this calendar	end tell -- done with application	return newEventend createRecurEvent